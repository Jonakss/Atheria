# Particle Emergence in Native Engine

This document explains the logic behind "Particle Emergence" in the Native Engine (C++) of Atheria, specifically how the sparse simulation state is initialized from a dense quantum state.

## Overview

The Native Engine operates on a **Sparse Grid** principle. Unlike the Python engine which computes the entire $N \times N$ grid (Dense), the Native Engine only stores and computes "active" cells (Particles) and their immediate neighbors.

"Particle Emergence" refers to the process of identifying which cells in a dense quantum state (generated by the initial state generator or loaded from a checkpoint) should be treated as active particles in the sparse engine.

## Initialization Process

The initialization logic is handled in `src/engines/native_engine_wrapper.py`, specifically in the `_initialize_native_state_from_dense` method.

### 1. Dense State Generation
First, a dense quantum state $\psi$ is generated using the standard `QuantumState` class (Python). This ensures consistency with the Python engine and supports all initialization modes (e.g., `complex_noise`, `gaussian_packet`).

### 2. Density Calculation
The probability density $|\psi|^2$ is calculated for every cell in the grid.
```python
psi_abs = dense_psi.abs()
psi_abs_sq = psi_abs.pow(2)
```

### 3. Threshold Determination
A dynamic threshold is calculated to distinguish "signal" (particles) from "noise" (vacuum fluctuations).
The threshold is set to **0.01%** of the maximum density in the grid, with a hard floor of $10^{-9}$.

$$ T = \max(\max(|\psi|^2) \times 0.0001, 10^{-9}) $$

This relative threshold ensures that:
- In high-energy states, we capture the main features without tracking negligible tails.
- In low-energy states (vacuum), we still capture the dominant fluctuations.

### 4. Particle Transfer
The wrapper iterates through the dense grid (with sampling for very large grids > 256x256) and checks the density of each cell.
If $Density(x, y) > T$, a particle is created in the Native Engine at coordinates $(x, y, 0)$ with the complex state vector from the dense grid.

```python
if cell_density > threshold:
    native_engine.add_particle(coord, cell_state)
```

### 5. Verification
After transfer, the wrapper performs a "sanity check" by attempting to retrieve a sample of the added particles from the Native Engine. This ensures that the C++ backend correctly stored the data.

## Dynamic Emergence (Simulation)

During simulation, particles can "move" or "propagate" to empty cells.
- The Native Engine processes the **Active Region** (Particles + Neighbors).
- If a particle at $(x, y)$ has a non-zero influence on a neighbor $(x+1, y)$ (via the convolution kernel), the neighbor becomes active in the next step.
- This allows particles to "emerge" in empty space adjacent to existing particles (propagation).
- **Tunneling**: True tunneling (emergence in non-adjacent cells) is NOT supported by the local CNN kernel unless implemented via global coupling or spectral methods (Harmonic Engine).

## Limitations

- **Threshold Sensitivity**: If the threshold is too high, weak particles might be clipped. If too low, the sparse engine fills up with noise, degrading performance.
- **Z-Axis**: Currently, the initialization only populates the $Z=0$ plane, effectively running a 2D simulation in the 3D engine.
