name: Version Bump AutomÃ¡tico

on:
  pull_request:
    types: [closed]
    branches:
      - main
      - master
  push:
    branches:
      - main
      - master
    # No ignorar ningÃºn path para que el workflow siempre se ejecute si hay push con tag
    # paths-ignore:
    #   - '**.md'
    #   - 'docs/**'
    #   - '.github/**'
  workflow_dispatch:
    inputs:
      version_type:
        description: "Tipo de bump de versiÃ³n"
        required: true
        type: choice
        options:
          - major
          - minor
          - patch

jobs:
  bump-version:
    runs-on: ubuntu-latest
    # Ejecutar si:
    # 1. PR fue mergeado (verificaremos labels despuÃ©s), O
    # 2. Push directo a main/master (verificaremos tags en commits despuÃ©s), O
    # 3. Workflow manual
    # NOTA: Verificamos tags/labels dentro del job, no en la condiciÃ³n if
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch'

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout cÃ³digo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0 # Necesario para comparar commits

      - name: Verificar si solo son cambios de documentaciÃ³n o no-frontend
        id: check-docs-only
        run: |
          # Default to not skipping
          echo "skip=false" >> $GITHUB_OUTPUT

          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "Verificando archivos en el PR #${{ github.event.pull_request.number }}..."
            files=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files" | \
              jq -r '.[].filename')
          elif [ "${{ github.event_name }}" == "push" ]; then
            echo "Verificando archivos en el push (commit ${{ github.sha }})..."
            # Compara el Ãºltimo commit (HEAD) con su predecesor (HEAD~1).
            # Esto funciona bien para el commit de merge que crea GitHub al fusionar un PR.
            files=$(git diff --name-only HEAD~1 HEAD)
          else
            files=""
          fi

          if [ -z "$files" ]; then
            echo "No se detectaron archivos modificados para analizar. Procediendo..."
            exit 0
          fi

          echo "Archivos modificados:"
          echo "$files"

          is_docs_only=true
          has_frontend_changes=false
          for file in $files; do
            # Si hay cambios fuera de docs/, no es docs-only
            if [[ ! "$file" == docs/* ]]; then
              is_docs_only=false
            fi
            # Si hay cambios en frontend/, registrar
            if [[ "$file" == frontend/* ]]; then
              has_frontend_changes=true
            fi
          done

          # Verificar si el commit tiene tag de versiÃ³n explÃ­cito
          COMMIT_MSG=$(git log -1 --format="%B" HEAD)
          has_version_tag=false
          if echo "$COMMIT_MSG" | grep -qi "\[version:bump:\|chore: bump version"; then
            has_version_tag=true
            echo "âœ… Commit contiene tag de versiÃ³n explÃ­cito"
          fi

          # Decidir si saltear el bump
          if $is_docs_only; then
            echo "âœ… La operaciÃ³n solo contiene cambios en 'docs/'. Saltando bump de versiÃ³n."
            echo "skip=true" >> $GITHUB_OUTPUT
          elif ! $has_frontend_changes && ! $has_version_tag; then
            echo "â­ï¸  No hay cambios en frontend/ ni tag de versiÃ³n. Saltando bump de versiÃ³n."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "ðŸ“ La operaciÃ³n contiene cambios de frontend o tag de versiÃ³n. Procediendo con el bump."
            echo "has_frontend_changes=$has_frontend_changes" >> $GITHUB_OUTPUT
          fi

      - name: Determinar tipo de bump
        id: version-bump
        if: steps.check-docs-only.outputs.skip != 'true'
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Workflow manual: usar input directamente
            echo "type=${{ github.event.inputs.version_type }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "push" ]; then
            # Push directo: revisar mensaje de commit para [version:bump:major/minor/patch]
            # IMPORTANTE: En push, github.event.head_commit.message puede estar vacÃ­o si es un push de mÃºltiples commits
            # Revisar el Ãºltimo commit del push usando git log
            COMMIT_MSG=$(git log -1 --format="%B" HEAD)
            echo "Mensaje de commit (HEAD): $COMMIT_MSG"
            
            # TambiÃ©n intentar con github.event.head_commit.message como fallback
            if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" == "" ]; then
              COMMIT_MSG="${{ github.event.head_commit.message }}"
              echo "Mensaje de commit (event): $COMMIT_MSG"
            fi
            
            # Buscar en todos los commits del push si el mensaje estÃ¡ vacÃ­o
            if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" == "" ]; then
              echo "âš ï¸ No se pudo obtener mensaje del commit, buscando en Ãºltimos 5 commits..."
              COMMIT_MSG=$(git log -5 --format="%B" | grep -E "\[version:bump" | head -1)
              echo "Tag encontrado en historial: $COMMIT_MSG"
            fi
            
            if echo "$COMMIT_MSG" | grep -qi "\[version:bump:major\]\|\[version:major\]"; then
              echo "type=major" >> $GITHUB_OUTPUT
              echo "âœ… Detectado bump MAJOR"
            elif echo "$COMMIT_MSG" | grep -qi "\[version:bump:minor\]\|\[version:minor\]"; then
              echo "type=minor" >> $GITHUB_OUTPUT
              echo "âœ… Detectado bump MINOR"
            elif echo "$COMMIT_MSG" | grep -qi "\[version:bump:patch\]\|\[version:patch\]"; then
              echo "type=patch" >> $GITHUB_OUTPUT
              echo "âœ… Detectado bump PATCH"
            else
              # Si no hay tag explÃ­cito en commit, no hacer bump
              echo "âš ï¸ Commit sin tag de versiÃ³n [version:bump:*], saltando bump"
              echo "skip=true" >> $GITHUB_OUTPUT
              # IMPORTANTE: NO hacer exit 0 aquÃ­ porque necesitamos continuar para crear el output
              # En su lugar, estableceremos un flag que se verifique despuÃ©s
            fi
          else
            # Pull Request: revisar labels del PR
            LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"
            echo "Labels encontrados: $LABELS"
            
            if echo "$LABELS" | grep -qi "version:major\|major-version\|breaking"; then
              echo "type=major" >> $GITHUB_OUTPUT
            elif echo "$LABELS" | grep -qi "version:minor\|minor-version\|feature"; then
              echo "type=minor" >> $GITHUB_OUTPUT
            elif echo "$LABELS" | grep -qi "version:patch\|patch-version\|bugfix\|fix"; then
              echo "type=patch" >> $GITHUB_OUTPUT
            else
              # Por defecto, patch si no hay label explÃ­cito
              echo "type=patch" >> $GITHUB_OUTPUT
              echo "âš ï¸ No se encontrÃ³ label de versiÃ³n, usando 'patch' por defecto"
            fi
          fi

      - name: Leer versiÃ³n actual
        id: current-version
        if: steps.version-bump.outputs.skip != 'true' && steps.check-docs-only.outputs.skip != 'true'
        run: |
          # Leer versiÃ³n desde src/__version__.py (fuente de verdad principal)
          CURRENT_VERSION=$(grep -E '^__version__\s*=' src/__version__.py | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/")
          if [ -z "$CURRENT_VERSION" ]; then
            CURRENT_VERSION="4.1.0"  # Fallback
          fi
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ VersiÃ³n actual: $CURRENT_VERSION"

          # Parsear versiÃ³n
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

      - name: Calcular nueva versiÃ³n
        id: new-version
        if: steps.version-bump.outputs.skip != 'true' && steps.check-docs-only.outputs.skip != 'true'
        run: |
          BUMP_TYPE="${{ steps.version-bump.outputs.type }}"
          CURRENT_MAJOR="${{ steps.current-version.outputs.major }}"
          CURRENT_MINOR="${{ steps.current-version.outputs.minor }}"
          CURRENT_PATCH="${{ steps.current-version.outputs.patch }}"

          case $BUMP_TYPE in
            major)
              NEW_MAJOR=$((CURRENT_MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            minor)
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$((CURRENT_MINOR + 1))
              NEW_PATCH=0
              ;;
            patch)
              NEW_MAJOR=$CURRENT_MAJOR
              NEW_MINOR=$CURRENT_MINOR
              NEW_PATCH=$((CURRENT_PATCH + 1))
              ;;
          esac

          NEW_VERSION="${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "major=$NEW_MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$NEW_MINOR" >> $GITHUB_OUTPUT
          echo "patch=$NEW_PATCH" >> $GITHUB_OUTPUT
          echo "ðŸš€ Nueva versiÃ³n: $NEW_VERSION (bump: $BUMP_TYPE)"

      - name: Configurar Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Instalar herramientas necesarias
        run: |
          # Instalar jq para manejar JSON si no estÃ¡ disponible
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Actualizar versiones en archivos
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.version }}"
          NEW_MAJOR="${{ steps.new-version.outputs.major }}"
          NEW_MINOR="${{ steps.new-version.outputs.minor }}"
          NEW_PATCH="${{ steps.new-version.outputs.patch }}"

          echo "ðŸ“ Actualizando versiones en archivos..."

          # 1. src/__version__.py
          sed -i "s/^__version__ = \".*\"/__version__ = \"$NEW_VERSION\"/" src/__version__.py
          sed -i "s/^__version_info__ = (.*)/__version_info__ = ($NEW_MAJOR, $NEW_MINOR, $NEW_PATCH)/" src/__version__.py
          echo "  âœ… src/__version__.py actualizado a $NEW_VERSION"

          # 2. src/engines/__version__.py
          if [ -f "src/engines/__version__.py" ]; then
            sed -i "s/^ENGINE_VERSION = \".*\"/ENGINE_VERSION = \"$NEW_VERSION\"/" src/engines/__version__.py
            echo "  âœ… src/engines/__version__.py actualizado a $NEW_VERSION"
          fi

          # 3. src/cpp_core/include/version.h
          if [ -f "src/cpp_core/include/version.h" ]; then
            sed -i "s/^#define ATHERIA_NATIVE_VERSION_MAJOR .*/#define ATHERIA_NATIVE_VERSION_MAJOR $NEW_MAJOR/" src/cpp_core/include/version.h
            sed -i "s/^#define ATHERIA_NATIVE_VERSION_MINOR .*/#define ATHERIA_NATIVE_VERSION_MINOR $NEW_MINOR/" src/cpp_core/include/version.h
            sed -i "s/^#define ATHERIA_NATIVE_VERSION_PATCH .*/#define ATHERIA_NATIVE_VERSION_PATCH $NEW_PATCH/" src/cpp_core/include/version.h
            sed -i "s/^#define ATHERIA_NATIVE_VERSION_STRING \".*\"/#define ATHERIA_NATIVE_VERSION_STRING \"$NEW_VERSION\"/" src/cpp_core/include/version.h
            echo "  âœ… src/cpp_core/include/version.h actualizado a $NEW_VERSION"
          fi

          # 4. frontend/package.json
          if [ -f "frontend/package.json" ]; then
            # Usar jq para manejar JSON correctamente
            jq ".version = \"$NEW_VERSION\"" frontend/package.json > frontend/package.json.tmp && mv frontend/package.json.tmp frontend/package.json
            echo "  âœ… frontend/package.json actualizado a $NEW_VERSION"
          fi

          echo "âœ… Todas las versiones actualizadas a $NEW_VERSION"

      - name: Verificar cambios
        run: |
          echo "ðŸ“‹ Verificando cambios en archivos de versiÃ³n:"
          git diff --name-only
          echo ""
          echo "ðŸ“ Cambios detallados:"
          git diff || true

      - name: Crear commit con versiones actualizadas
        if: steps.version-bump.outputs.skip != 'true' && steps.check-docs-only.outputs.skip != 'true'
        run: |
          git add -A
          git commit -m "chore: bump version to ${{ steps.new-version.outputs.version }} [skip ci]"

          # Push del commit
          git push origin HEAD:main || git push origin HEAD:master

      - name: Crear tag de versiÃ³n
        if: steps.version-bump.outputs.skip != 'true' && steps.check-docs-only.outputs.skip != 'true'
        run: |
          NEW_VERSION="${{ steps.new-version.outputs.version }}"
          git tag -a "v${NEW_VERSION}" -m "Release version ${NEW_VERSION}"
          git push origin "v${NEW_VERSION}"
          echo "ðŸ·ï¸  Tag v${NEW_VERSION} creado y pusheado"

      - name: Crear Release
        if: steps.version-bump.outputs.skip != 'true' && steps.check-docs-only.outputs.skip != 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.new-version.outputs.version }}
          name: "Release v${{ steps.new-version.outputs.version }}"
          body: |
            ## ðŸš€ Release v${{ steps.new-version.outputs.version }}

            **Tipo de bump:** ${{ steps.version-bump.outputs.type }}

            ### ðŸ“ Cambios
            ${{ github.event.pull_request.body || 'Ver commits para detalles' }}

            ### ðŸ“¦ Componentes actualizados
            - âœ… Backend Python: v${{ steps.new-version.outputs.version }}
            - âœ… Motor Nativo C++: v${{ steps.new-version.outputs.version }}
            - âœ… Frontend React: v${{ steps.new-version.outputs.version }}

          draft: false
          prerelease: false

      - name: Resumen
        if: steps.version-bump.outputs.skip != 'true' && steps.check-docs-only.outputs.skip != 'true'
        run: |
          echo "## âœ… VersiÃ³n actualizada exitosamente" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **VersiÃ³n anterior:** ${{ steps.current-version.outputs.current }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Nueva versiÃ³n:** ${{ steps.new-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tipo de bump:** ${{ steps.version-bump.outputs.type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag creado:** v${{ steps.new-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
